<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LexicalAnalysis</name>
    </assembly>
    <members>
        <member name="T:myExtension.Lexer">
            <summary>
            Classe que contém todos os métodos utilizados durante a execução do analisador léxico
            </summary>
        </member>
        <member name="M:myExtension.Lexer.readFile(System.String)">
            <summary>
            Método usado para ler o arquivo que seria o programa em PasC de acordo com o botão pressionado.      
            </summary>
            <param name="nomeArquivo">string com o nome do arquivo que será lido</param>
            <returns>Mensagem de teste com o conteúdo do arquivo.</returns>
            <remarks>Deve ser implementado quando for necessário ler um novo arquivo de programa PasC.</remarks>
        </member>
        <member name="M:myExtension.Lexer.performsAutomaton">
            <summary>
            Método utilizado para executar o autômato analisará o lexico da linguagem PasC
            </summary>
            <param name="readText"></param>
            <param name="entrada"></param>
            <param name="ST"></param>
            <param name="outputSet"></param>
            <returns>Token</returns>
            <remarks>Deve ser chamado para iniciar a execução do autômato</remarks>
        </member>
        <member name="M:myExtension.Lexer.currentLineAndColumn(System.Int32,System.Int32)">
            <summary>
            Método para sinalizar um erro e o lugar onde ele foi encontrado
            </summary>
            <param name="column">Representa a coluna atual que o leitor está</param>
            <param name="line">Representa a linha atual que o leitor está</param>
            <returns>Retorna a posição atual da linha e da coluna</returns>
        </member>
        <member name="M:myExtension.Lexer.flagError(System.String,System.Int32,System.Int32)">
            <summary>
            Método para sinalizar um erro e o lugar onde ele foi encontrado
            </summary>
        </member>
        <member name="M:myExtension.Lexer.CloseFile">
            <summary>
            Método usado para fechar o arquivo após a leitura
            </summary>
            <param name="entrada"></param>
            <param name="readText"></param>
        </member>
        <member name="F:LexicalAnalysis.SeeTokens.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:LexicalAnalysis.SeeTokens.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:LexicalAnalysis.SeeTokens.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:LexicalAnalysis.SymbolTable">
            <summary>
            Classe que contem as funcionalidades para a Tabela de Símbolos
            </summary>
        </member>
        <member name="M:LexicalAnalysis.SymbolTable.isLexemaOnSymbolTable(LexicalAnalysis.Tag,System.String,System.Int32,System.Int32)">
            <summary>
            Verifica se já tem esse lexema na Tabela de símbolos. Se tiver, retorna ele. Se não tiver, adiciona e retorna ele.
            </summary>
            <param name="tag">O tipo do lexema encontrado</param>
            <param name="completeWord">A StringBiulder construida </param>
            <param name="countColumn">Posição atual da coluna</param>
            <param name="countLine">Posição atual da linha</param>
            <returns></returns>
        </member>
        <member name="F:LexicalAnalysis.Tag.EOF">
            <summary>
            Fim do arquivo
            </summary>
        </member>
        <member name="F:LexicalAnalysis.Tag.ID">
            <summary>
            Identificador
            </summary>
        </member>
        <member name="F:LexicalAnalysis.Tag.LIT">
            <summary>
            Literal
            </summary>
        </member>
        <member name="F:LexicalAnalysis.TelaInicial.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:LexicalAnalysis.TelaInicial.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:LexicalAnalysis.TelaInicial.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:LexicalAnalysis.Program.Main">
            <summary>
            The main entry point for the application.
            </summary>
        </member>
        <member name="T:LexicalAnalysis.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:LexicalAnalysis.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:LexicalAnalysis.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:SyntaxAnalysis.Parser">
            <summary>
            Classe que contém todos os métodos utilizados durante a execução do analisador sintático
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.#ctor(myExtension.Lexer,System.Collections.Generic.List{System.String})">
            <summary>
            Método construtor do Parser 
            </summary>
            <param name="entrada"></param>
            <param name="readText"></param>
            <param name="outputSet"></param>
            <param name="ST"></param>
            
        </member>
        <member name="M:SyntaxAnalysis.Parser.flagSyntaxError(System.String)">
            <summary>
            Método que retorna a mensagem dos erros sintáticos encontrados
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:SyntaxAnalysis.Parser.advance">
            <summary>
            Método que avança a entrada do caracter
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.eat(LexicalAnalysis.Tag)">
            <summary>
            Método que consome o caracter
            </summary>
            <param name="tag"></param>
            <returns></returns>
        </member>
        <member name="M:SyntaxAnalysis.Parser.prog">
            <summary>
            Método para o não terminal "prog"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.body">
            <summary>
            Método para o não terminal "body"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.decl_list">
            <summary>
            Método para o não terminal "decl-list"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.decl">
            <summary>
            Método para o não terminal "decl"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.type">
            <summary>
            Método para o não terminal "type"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.id_list1">
            <summary>
            Método para o não terminal "id-list"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.id_list2">
            <summary>
            Método para o não terminal " id-list' "
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.stmt_list">
            <summary>
            Método para o não terminal "stmt-list"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.stmt">
            <summary>
            Método para o não terminal "stmt"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.assign_stmt">
            <summary>
            Método para o não terminal "assign-stmt"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.If_stmt1">
            <summary>
            Método para o não terminal "if-stmt"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.If_stmt2">
            <summary>
            Método para o não terminal " if-stmt' "
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.condition">
            <summary>
            Método para o não terminal "condition"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.While_stmt">
            <summary>
            Método para o não terminal "while-stmt"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.stmt_prefix">
            <summary>
            Método para o não terminal "stmt-prefix"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.read_stmt">
            <summary>
            Método para o não terminal "read-stmt"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.write_stmt">
            <summary>
            Método para o não terminal "write-stmt"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.writable">
            <summary>
            Método para o não terminal "writable"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.expression1">
            <summary>
            Método para o não terminal "expression"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.expression2">
            <summary>
            Método para o não terminal " expression' "
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.simple_expr1">
            <summary>
            Método para o não terminal "simple-expr"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.simple_expr2">
            <summary>
            Método para o não terminal " simple-expr' "
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.term1">
            <summary>
            Método para o não terminal "term"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.term2">
            <summary>
            Método para o não terminal " term' "
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.factor_a">
            <summary>
            Método para o não terminal "factor-a"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.factor">
            <summary>
            Método para o não terminal "factor"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.relop">
            <summary>
            Método para o não terminal "relop"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.addop">
            <summary>
            Método para o não terminal "addop"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.mulop">
            <summary>
            Método para o não terminal "mulop"
            </summary>
        </member>
        <member name="M:SyntaxAnalysis.Parser.constant">
            <summary>
            Método para o não terminal "constant"
            </summary>
        </member>
        <member name="T:Token">
            <summary>
            Classe para as regras do Token
            </summary>
        </member>
        <member name="P:Token.Coluna">
            <summary>
            Get/Set do atributo Coluna
            </summary>
        </member>
        <member name="M:Token.#ctor(LexicalAnalysis.Tag,System.String,System.Int32,System.Int32)">
            <summary>
            Construtor da classe Token 
            </summary>
            <param name="classe">Tag que define o lexema</param>
            <param name="lexema">Lexema formado ao ler o algoritmo PasC</param>
            <param name="linha">Linha que o token foi encontrado</param>
            <param name="coluna">Coluna que o token foi encontrado</param>
        </member>
        <member name="M:Token.ToString">
            <summary>
            Método de print da classe Token
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
